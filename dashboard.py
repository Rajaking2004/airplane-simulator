# ===============================================================================
# UNIFIED FLIGHT OPERATIONS DASHBOARD - FINAL INTEGRATED VERSION
# ===============================================================================
# Combines the advanced model outputs with a rich, interactive UI.
# Run this on your local machine after running the main Colab script.

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import json
import os
import time
import warnings

# Try to import optional packages for the advanced AI Assistant
try:
    from sentence_transformers import SentenceTransformer, util
    SENTENCE_TRANSFORMERS_AVAILABLE = True
except (ImportError, RuntimeError) as e:
    SENTENCE_TRANSFORMERS_AVAILABLE = False


warnings.filterwarnings('ignore')

# ===============================================================================
# PAGE CONFIGURATION & STYLING
# ===============================================================================

st.set_page_config(
    page_title="AI Flight Operations Center",
    page_icon="‚úàÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for a professional look and feel
st.markdown("""
<style>
.main-header {
    font-size: 2.5rem;
    color: #1f77b4;
    text-align: center;
    margin-bottom: 2rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
}
.metric-container {
    background: #f0f2f6;
    padding: 1.5rem;
    border-radius: 0.8rem;
    margin: 0.5rem 0;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}
.insight-box {
    background: #e8f4fd;
    padding: 1.5rem;
    border-radius: 0.8rem;
    border-left: 4px solid #1f77b4;
    margin: 1rem 0;
}
.success-box {
    background: #d1e7dd;
    padding: 1.5rem;
    border-radius: 0.8rem;
    border-left: 4px solid #198754;
    margin: 1rem 0;
}
.prediction-result {
    background: #f8f9fa;
    padding: 2rem;
    border-radius: 1rem;
    border: 1px solid #dee2e6;
    margin: 1rem 0;
    text-align: center;
}
.stButton > button {
    background: #1f77b4;
    color: white;
    border-radius: 0.5rem;
    font-weight: 600;
}
</style>
""", unsafe_allow_html=True)

# ===============================================================================
# DATA LOADING & CACHING
# ===============================================================================

@st.cache_data
def load_data():
    """Loads flight data and optimized schedule from CSV files generated by Colab."""
    data = {}
    try:
        df = pd.read_csv('flight_data_with_impact.csv')
        # Ensure datetime columns are correctly typed
        for col in ['std', 'sta']:
            if col in df.columns:
                df[col] = pd.to_datetime(df[col])
        data['main'] = df
    except FileNotFoundError:
        data['main'] = None

    try:
        opt_df = pd.read_csv('optimized_schedule.csv')
        for col in ['std', 'optimized_std']:
            if col in opt_df.columns:
                opt_df[col] = pd.to_datetime(opt_df[col])
        data['optimized'] = opt_df
    except FileNotFoundError:
        data['optimized'] = None
    return data


# ===============================================================================
# STATISTICAL PREDICTOR CLASS (For Interactive Predictor Page)
# ===============================================================================
class SimpleFlightPredictor:
    """A statistical predictor for the interactive 'Delay Predictor' page."""
    def __init__(self, df=None):
        self.df = df
        self.airline_stats = {}
        self.route_stats = {}
        self.hour_stats = {}
        self.model_ready = False
        if df is not None:
            self.prepare_statistics(df)

    def prepare_statistics(self, df):
        try:
            self.airline_stats = df.groupby('airline')['arr_delay'].agg(['mean', 'std', 'count']).to_dict('index')
            self.route_stats = df.groupby('to')['arr_delay'].agg(['mean', 'std', 'count']).to_dict('index')
            self.hour_stats = df.groupby('scheduled_hour')['arr_delay'].agg(['mean', 'std', 'count']).to_dict('index')
            self.overall_mean = df['arr_delay'].mean()
            self.overall_std = df['arr_delay'].std()
            self.delay_percentiles = {'75th': df['arr_delay'].quantile(0.75), '25th': df['arr_delay'].quantile(0.25)}
            self.model_ready = True
        except Exception as e:
            st.error(f"Error preparing predictor statistics: {e}")
            self.model_ready = False

    def predict_delay(self, flight_data):
        if not self.model_ready:
            return None, {}
        try:
            base_delay = self.overall_mean
            factor_contributions = {}
            confidence_factors = []

            # Weighted contributions from different factors
            factors = {
                'airline': (self.airline_stats, flight_data.get('airline'), 0.3),
                'route': (self.route_stats, flight_data.get('to'), 0.25),
                'hour': (self.hour_stats, flight_data.get('scheduled_hour'), 0.2)
            }
            for name, (stats, key, weight) in factors.items():
                if key in stats and stats[key]['count'] >= 5:
                    contribution = (stats[key]['mean'] - self.overall_mean) * weight
                    base_delay += contribution
                    factor_contributions[name] = contribution
                    confidence_factors.append(name)
            
            # Direct propagation from departure delay
            dep_delay = flight_data.get('dep_delay', 0)
            dep_contribution = dep_delay * 0.8
            base_delay += dep_contribution
            factor_contributions['departure_delay'] = dep_contribution

            predicted_delay = max(0, base_delay)
            confidence = min(95, 50 + len(confidence_factors) * 10)
            uncertainty = self.overall_std * (1 - confidence / 100)
            
            components = {
                'predicted_delay': predicted_delay,
                'confidence': confidence,
                'factor_contributions': factor_contributions,
                'prediction_interval': (max(0, predicted_delay - uncertainty), predicted_delay + uncertainty),
                'recommendations': self._generate_recommendations(predicted_delay)
            }
            return predicted_delay, components
        except Exception as e:
            st.error(f"Prediction error: {e}")
            return None, {}

    def _generate_recommendations(self, predicted_delay):
        recs = []
        if predicted_delay > 60:
            recs.append("üö® **Critical Delay Risk**: Immediate intervention required. Consider rebooking passengers.")
        elif predicted_delay > 30:
            recs.append("üü† **High Delay Risk**: Proactive passenger communication and ground crew alerts recommended.")
        elif predicted_delay > 15:
            recs.append("üü° **Medium Delay Risk**: Monitor flight closely and prepare for potential gate changes.")
        else:
            recs.append("‚úÖ **Low Delay Risk**: Flight expected to operate within normal parameters.")
        return recs

# ===============================================================================
# AI ASSISTANT (Semantic & Keyword-based NLP)
# ===============================================================================
@st.cache_resource
def get_nlp_assistant(df):
    """Loads and caches the semantic NLP model if available."""
    if not SENTENCE_TRANSFORMERS_AVAILABLE or df is None:
        return None

    class SemanticNLPAssistant:
        def __init__(self, df):
            self.df = df
            self.model = SentenceTransformer('all-MiniLM-L6-v2')
            self.known_questions = [
                "What are the busiest hours?", "Show airline performance.",
                "Which routes have the most delays?", "What is the airport congestion?"
            ]
            self.known_embeddings = self.model.encode(self.known_questions)

        def process_query(self, query):
            query_embedding = self.model.encode(query)
            cosine_scores = util.cos_sim(query_embedding, self.known_embeddings)[0]
            best_match_idx = np.argmax(cosine_scores)
            if cosine_scores[best_match_idx] > 0.5:
                return self._get_answer(int(best_match_idx))
            return "I'm not sure how to answer that. Please try rephrasing or ask a more general question about airport operations."

        def _get_answer(self, index):
            if index == 0 or index == 3: # Busiest hours / Congestion
                analysis = self.df.groupby('scheduled_hour')['flight_id'].count().nlargest(5)
                return f"**The busiest hours by flight volume are:**\n\n```\n{analysis.to_string()}\n```"
            elif index == 1: # Airline performance
                analysis = self.df.groupby('airline')['arr_delay'].mean().sort_values()
                return f"**Airline performance by average delay (minutes):**\n\n```\n{analysis.round(1).to_string()}\n```"
            elif index == 2: # Route delays
                analysis = self.df.groupby('to')['arr_delay'].mean().nlargest(5)
                return f"**The routes with the highest average delays are:**\n\n```\n{analysis.round(1).to_string()}\n```"
            return "Analysis not implemented."
    
    return SemanticNLPAssistant(df)

def keyword_based_nlp(query, df):
    """Provides a detailed keyword-based analysis as a fallback."""
    query = query.lower().strip()
    if any(word in query for word in ['busiest', 'peak', 'traffic']):
        analysis = df.groupby('scheduled_hour')['flight_id'].count().nlargest(3)
        return f"**Peak traffic hours by flight volume:**\n\n```\n{analysis.to_string()}\n```"
    elif any(word in query for word in ['airline', 'carrier', 'performance']):
        analysis = df.groupby('airline')['arr_delay'].mean().sort_values().round(1)
        return f"**Airline performance (average arrival delay):**\n\n```\n{analysis.to_string()}\n```"
    else:
        on_time_perf = (df['arr_delay'] <= 15).mean() * 100
        response = f"**I couldn't find a specific match. Here's a general overview:**\n\n"
        response += f"- **Total Flights:** {len(df):,}\n"
        response += f"- **Average Delay:** {df['arr_delay'].mean():.1f} min\n"
        response += f"- **On-Time Performance:** {on_time_perf:.1f}%\n\n"
        response += "**Try asking about:** 'busiest hours', 'airline performance', or 'route delays'."
        return response

# ===============================================================================
# DASHBOARD PAGES
# ===============================================================================

def show_overview_page(df):
    st.header("üè† Executive Overview")
    if df is None:
        st.error("Flight data not found. Please run the Colab script and place 'flight_data_with_impact.csv' in the same directory.")
        return

    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Total Flights", f"{len(df):,}")
    col2.metric("Average Delay", f"{df['arr_delay'].mean():.1f} min")
    col3.metric("On-Time Performance (<=15min)", f"{(df['arr_delay'] <= 15).mean()*100:.1f}%")
    if 'impact_score' in df.columns:
        col4.metric("High-Impact Flights (>80)", f"{(df['impact_score'] > 80).sum()}")

    st.subheader("Airport Congestion & Average Delay by Hour")
    if 'scheduled_hour' in df.columns:
        hourly_analysis = df.groupby('scheduled_hour').agg(
            flight_count=('flight_id', 'count'),
            avg_delay=('arr_delay', 'mean')
        ).reset_index()
        
        fig = make_subplots(specs=[[{"secondary_y": True}]])
        fig.add_trace(go.Bar(x=hourly_analysis['scheduled_hour'], y=hourly_analysis['flight_count'], name='Flight Count'), secondary_y=False)
        fig.add_trace(go.Scatter(x=hourly_analysis['scheduled_hour'], y=hourly_analysis['avg_delay'], name='Average Delay (min)', mode='lines+markers'), secondary_y=True)
        
        fig.update_layout(title_text="Hourly Airport Operations Analysis")
        fig.update_xaxes(title_text="Hour of Day")
        fig.update_yaxes(title_text="Number of Flights", secondary_y=False)
        fig.update_yaxes(title_text="Average Delay (min)", secondary_y=True)
        
        st.plotly_chart(fig, use_container_width=True)

def show_impact_analysis_page(df):
    st.header("üí• Cascading Impact Analysis")
    st.markdown("""
    This page uses a **Graph Network Model (PageRank)** to identify flights that are most critical to the schedule.
    A high **Impact Score** indicates a 'super-spreader' flight, where a delay is likely to cascade and disrupt many other flights.
    """)
    if df is None or 'impact_score' not in df.columns:
        st.error("Impact analysis data not found. Please ensure the Colab script with NetworkX ran successfully.")
        return

    st.subheader("Top 15 Most Influential Flights")
    top_disruptors = df.sort_values('impact_score', ascending=False).head(15)
    st.dataframe(top_disruptors[['flight_id', 'std', 'to', 'aircraft', 'impact_score']].round(2), use_container_width=True)
    
    st.subheader("Distribution of Impact Scores")
    fig = px.histogram(df, x='impact_score', title="Flight Impact Score Distribution", nbins=50)
    st.plotly_chart(fig, use_container_width=True)

def show_optimizer_page(optimized_df, original_df):
    st.header("üß† CP-SAT Schedule Optimizer")
    st.markdown("""
    This page shows the mathematically optimal schedule found by **Google's CP-SAT Solver**.
    The solver rearranges flights to minimize total deviation from the original schedule while respecting runway capacity constraints, effectively de-congesting peak hours.
    """)
    if optimized_df is None:
        st.error("Optimized schedule not found. Please ensure the Colab script ran successfully and 'optimized_schedule.csv' is present.")
        return

    st.subheader("Peak Hour Decongestion: Original vs. Optimized Schedule")
    original_traffic = original_df.groupby(original_df['std'].dt.hour)['flight_id'].count()
    optimized_traffic = optimized_df.groupby(optimized_df['optimized_std'].dt.hour)['flight_id'].count()

    fig = go.Figure()
    fig.add_trace(go.Bar(x=original_traffic.index, y=original_traffic.values, name='Original Schedule', marker_color='indianred'))
    fig.add_trace(go.Bar(x=optimized_traffic.index, y=optimized_traffic.values, name='Optimized Schedule', marker_color='lightseagreen'))
    fig.update_layout(barmode='group', xaxis_title='Hour of Day', yaxis_title='Number of Flights', title='Hourly Flight Load Comparison')
    st.plotly_chart(fig, use_container_width=True)

    st.subheader("Detailed Schedule Changes")
    optimized_df['deviation (min)'] = (optimized_df['optimized_std'] - optimized_df['std']).dt.total_seconds() / 60
    st.dataframe(optimized_df[['flight_id', 'std', 'optimized_std', 'deviation (min)']].round(0), use_container_width=True)

def show_predictor_page(df, predictor):
    st.header("üîÆ Interactive Delay Predictor")
    st.markdown("""
    <div class="insight-box">
    <h4>üéØ Intelligent Delay Forecasting</h4>
    <p>Configure a hypothetical flight using the controls below. This tool uses a statistical model based on historical data to forecast the potential arrival delay and provide operational recommendations.</p>
    </div>
    """, unsafe_allow_html=True)
    
    if df is None or predictor is None or not predictor.model_ready:
        st.error("Predictor could not be initialized. Please ensure flight data is loaded correctly.")
        return

    with st.form("prediction_form"):
        col1, col2, col3 = st.columns(3)
        with col1:
            airline = st.selectbox("Airline:", sorted(df['airline'].unique()))
            destination = st.selectbox("Destination:", sorted(df['to'].unique()))
        with col2:
            scheduled_hour = st.slider("Scheduled Hour:", 0, 23, 10)
            dep_delay = st.slider("Known Departure Delay (min):", 0, 120, 0)
        with col3:
            day_of_week_str = st.selectbox("Day of Week:", ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'])
            day_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].index(day_of_week_str)

        predict_button = st.form_submit_button("üîÆ Generate Prediction", type="primary")

    if predict_button:
        prediction_data = {'airline': airline, 'to': destination, 'scheduled_hour': scheduled_hour, 'dep_delay': dep_delay, 'day_of_week': day_of_week}
        predicted_delay, components = predictor.predict_delay(prediction_data)

        if predicted_delay is not None:
            st.markdown('<div class="prediction-result">', unsafe_allow_html=True)
            res_col1, res_col2, res_col3 = st.columns(3)
            res_col1.metric("Predicted Delay", f"{predicted_delay:.0f} min")
            res_col2.metric("Confidence", f"{components['confidence']:.0f}%")
            lower, upper = components['prediction_interval']
            res_col3.metric("95% Interval", f"{lower:.0f}-{upper:.0f} min")
            st.markdown('</div>', unsafe_allow_html=True)
            
            st.subheader("üí° Operational Recommendations")
            for rec in components.get('recommendations', []):
                st.markdown(f"- {rec}")

            st.subheader("üîç Prediction Factor Analysis")
            contributions = components.get('factor_contributions', {})
            if contributions:
                fig = px.bar(x=contributions.values(), y=list(contributions.keys()), orientation='h',
                             labels={'x': 'Contribution to Delay (min)', 'y': 'Factor'}, title="How Each Factor Influenced the Prediction")
                st.plotly_chart(fig, use_container_width=True)

def show_simulation_page(df):
    st.header("üé≠ What-If Scenario Simulator")
    st.markdown("""
    <div class="insight-box">
    <h4>üéÆ Stress-Test Your Operations</h4>
    <p>Adjust the sliders to simulate different operational conditions like bad weather or high congestion. The simulator will calculate the impact on key performance indicators (KPIs) based on historical data.</p>
    </div>
    """, unsafe_allow_html=True)

    if df is None:
        st.error("Simulation requires flight data. Please load the data first.")
        return

    st.subheader("‚öôÔ∏è Simulation Configuration")
    col1, col2 = st.columns(2)
    with col1:
        weather_impact = st.slider("Weather Severity (1=Normal, >1=Worse)", 1.0, 3.0, 1.0, 0.1)
    with col2:
        congestion_factor = st.slider("Congestion Multiplier", 1.0, 3.0, 1.0, 0.1)
    
    if st.button("üöÄ Run Simulation", type="primary"):
        with st.spinner("Running simulation..."):
            sim_df = df.copy()
            # Apply weather effect: increases baseline delay
            sim_df['simulated_delay'] = sim_df['arr_delay'] * weather_impact
            # Apply congestion effect: adds delay based on hourly traffic
            congestion_delay = (sim_df['hourly_flight_count'] - sim_df['hourly_flight_count'].mean()) * congestion_factor
            sim_df['simulated_delay'] += congestion_delay.clip(lower=0)
            sim_df['simulated_delay'] = sim_df['simulated_delay'].clip(lower=0)

        st.success("‚úÖ Simulation Complete!")
        st.subheader("üìä Simulation Results")
        
        res_col1, res_col2, res_col3 = st.columns(3)
        res_col1.metric("Simulated Avg Delay", f"{sim_df['simulated_delay'].mean():.1f} min", delta=f"{sim_df['simulated_delay'].mean() - df['arr_delay'].mean():.1f} min vs. Baseline")
        sim_otp = (sim_df['simulated_delay'] <= 15).mean() * 100
        base_otp = (df['arr_delay'] <= 15).mean() * 100
        res_col2.metric("Simulated On-Time %", f"{sim_otp:.1f}%", delta=f"{sim_otp - base_otp:.1f}% vs. Baseline")
        sim_severe = (sim_df['simulated_delay'] > 60).sum()
        base_severe = (df['arr_delay'] > 60).sum()
        res_col3.metric("Severely Delayed Flights", f"{sim_severe:,}", delta=f"{sim_severe - base_severe:,} vs. Baseline")

        fig = go.Figure()
        fig.add_trace(go.Histogram(x=df['arr_delay'], name='Baseline', opacity=0.75, nbinsx=50))
        fig.add_trace(go.Histogram(x=sim_df['simulated_delay'], name='Simulated', opacity=0.75, nbinsx=50))
        fig.update_layout(barmode='overlay', title_text="Delay Distribution: Baseline vs. Simulated Scenario", xaxis_title="Arrival Delay (minutes)")
        st.plotly_chart(fig, use_container_width=True)


def show_nlp_page(nlp_assistant, df):
    st.header("ü§ñ AI Flight Operations Assistant")
    st.markdown("""
    Ask questions in natural language. Our AI assistant uses a lightweight transformer model to understand the *meaning* of your query. 
    If the advanced model is unavailable, it will fall back to a keyword-based search.
    """)
    if df is None:
        st.error("AI Assistant requires flight data to be loaded.")
        return

    if not SENTENCE_TRANSFORMERS_AVAILABLE:
        st.warning("Advanced NLP model could not be loaded. Falling back to basic keyword search. To enable, run: pip install sentence-transformers tf-keras")

    user_query = st.text_input("Ask about your flight operations:", placeholder="e.g., Which routes have the most delays?")
    
    q_cols = st.columns(3)
    quick_queries = ["Busiest hours", "Best airline performance", "Most delayed routes"]
    if 'query_button_clicked' not in st.session_state:
        st.session_state.query_button_clicked = None
    
    for i, q in enumerate(quick_queries):
        if q_cols[i].button(q):
            st.session_state.query_button_clicked = q

    if st.session_state.query_button_clicked:
        user_query = st.session_state.query_button_clicked
        st.session_state.query_button_clicked = None # Reset after use
    
    if user_query:
        with st.spinner("ü§î Analyzing your query..."):
            if nlp_assistant:
                response = nlp_assistant.process_query(user_query)
            else:
                response = keyword_based_nlp(user_query, df)
            
            st.markdown("### üìã Analysis Results")
            st.markdown(f'<div class="insight-box">{response}</div>', unsafe_allow_html=True)


def show_diagnostics_page(df, optimized_df, nlp_assistant):
    st.header("‚öôÔ∏è System Diagnostics")
    st.subheader("üè• System Health Overview")
    
    col1, col2, col3, col4 = st.columns(4)
    data_health = "Healthy" if df is not None else "Missing"
    col1.metric("Core Data Status", data_health)
    
    optimizer_health = "Loaded" if optimized_df is not None else "Missing"
    col2.metric("Optimizer Data", optimizer_health)

    nlp_health = "Semantic" if nlp_assistant is not None else "Keyword"
    col3.metric("AI Assistant Mode", nlp_health)
    
    mem_usage = f"{df.memory_usage(deep=True).sum() / 1024**2:.1f} MB" if df is not None else "N/A"
    col4.metric("Memory Usage", mem_usage)
    
    if df is not None:
        st.subheader("üìä Data Quality Assessment")
        missing_values = df.isnull().sum().sum()
        completeness = (1 - missing_values / df.size) * 100
        
        qual_col1, qual_col2 = st.columns(2)
        qual_col1.metric("Data Completeness", f"{completeness:.2f}%")
        qual_col2.metric("Total Missing Values", f"{missing_values:,}")
        st.dataframe(df.isnull().sum().rename("Missing Values per Column").to_frame(), use_container_width=True)

# ===============================================================================
# MAIN APPLICATION
# ===============================================================================

def main():
    """Main function to run the Streamlit application."""
    st.markdown('<h1 class="main-header">‚úàÔ∏è Unified AI Flight Operations Center</h1>', unsafe_allow_html=True)

    data = load_data()
    df = data.get('main')
    optimized_df = data.get('optimized')
    
    predictor = SimpleFlightPredictor(df) if df is not None else None
    nlp_assistant = get_nlp_assistant(df)

    with st.sidebar:
        st.markdown("### üß≠ Navigation")
        page = st.selectbox(
            "Choose a Dashboard:",
            [
                "üè† Executive Overview",
                "üí• Cascading Impact",
                "üß† Schedule Optimizer",
                "üîÆ Delay Predictor",
                "üé≠ Scenario Simulator",
                "ü§ñ AI Assistant",
                "‚öôÔ∏è System Diagnostics"
            ]
        )
        st.markdown("---")
        st.markdown("### üìä System Status")
        st.success(f"‚úÖ Core Data: {'Loaded' if df is not None else 'Missing'}")
        st.success(f"‚úÖ Optimizer: {'Loaded' if optimized_df is not None else 'Missing'}")
        st.success(f"‚úÖ AI Assistant: {'Semantic' if nlp_assistant else 'Keyword'}")

    # Page Routing
    if page == "üè† Executive Overview":
        show_overview_page(df)
    elif page == "üí• Cascading Impact":
        show_impact_analysis_page(df)
    elif page == "üß† Schedule Optimizer":
        if df is not None and optimized_df is not None:
            original_subset = df[df['flight_id'].isin(optimized_df['flight_id'])]
            show_optimizer_page(optimized_df, original_subset)
        else:
            st.error("Optimizer page requires both 'flight_data_with_impact.csv' and 'optimized_schedule.csv'.")
    elif page == "üîÆ Delay Predictor":
        show_predictor_page(df, predictor)
    elif page == "üé≠ Scenario Simulator":
        show_simulation_page(df)
    elif page == "ü§ñ AI Assistant":
        show_nlp_page(nlp_assistant, df)
    elif page == "‚öôÔ∏è System Diagnostics":
        show_diagnostics_page(df, optimized_df, nlp_assistant)


if __name__ == "__main__":
    main()